/**
 * 통과 여부 : 통과
 * 시간 : 1시간
 * 점수 : + 8
 */

/**
 * @todo 도달했으나 클리어 x 플레이어의 수 / 스테이지에 도달한 플레이어 수
 * 뭐라는거임 !!!
 * @param {*} N 전체 스테이지 개수
 * @param {*} stages 게임을 이용하는 사용자가 현재 멈춰있는 스테이지 번호가 담긴 배열
 * @returns 실패율이 높은 스테이지부터 내림차순으로
 */
 function solution(N, stages) {
  let user = stages.length;
  let arr = stages.slice();
  let answer = [];

  arr.sort((a, b) => a - b);

  for (let i=0; i<N; i++) {
    let stageLength = arr.filter(el => el === i+1).length;
    answer.push([i+1, stageLength/user]);
    user -= stageLength;
  }
  // return에 연산 안하는 게 좋다고 해서
  return answer.sort((a, b) => b[1] - a[1]).map(el => el[0]);
 
}

/* return에 바로 연산 넣은 ..인데 얘가 더 빠르네 왜지
테스트 1 〉	통과 (0.28ms, 33.4MB)
테스트 2 〉	통과 (0.70ms, 33.6MB)
테스트 3 〉	통과 (114.55ms, 36.3MB)
테스트 4 〉	통과 (524.83ms, 41.1MB)
테스트 5 〉	통과 (1464.32ms, 48.5MB)
테스트 6 〉	통과 (2.45ms, 35.3MB)
테스트 7 〉	통과 (17.14ms, 36.1MB)
테스트 8 〉	통과 (432.85ms, 41MB)
테스트 9 〉	통과 (1422.01ms, 48.5MB)
테스트 10 〉	통과 (161.13ms, 40.7MB)
테스트 11 〉	통과 (425.81ms, 40.8MB)
테스트 12 〉	통과 (325.78ms, 42.9MB)
테스트 13 〉	통과 (699.22ms, 43.6MB)
테스트 14 〉	통과 (0.28ms, 33.4MB)
테스트 15 〉	통과 (40.53ms, 37.7MB)
테스트 16 〉	통과 (20.67ms, 38.2MB)
테스트 17 〉	통과 (37.64ms, 38.8MB)
테스트 18 〉	통과 (25.44ms, 38.2MB)
테스트 19 〉	통과 (3.46ms, 35.7MB)
테스트 20 〉	통과 (31.11ms, 39.8MB)
테스트 21 〉	통과 (46.86ms, 40.8MB)
테스트 22 〉	통과 (1833.10ms, 45.4MB)
테스트 23 〉	통과 (66.62ms, 45.6MB)
테스트 24 〉	통과 (138.48ms, 46.8MB)
테스트 25 〉	통과 (0.16ms, 33.4MB)
테스트 26 〉	통과 (0.13ms, 33.4MB)
테스트 27 〉	통과 (0.13ms, 33.3MB)
 */