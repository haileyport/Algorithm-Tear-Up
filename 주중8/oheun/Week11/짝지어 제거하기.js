/*
통과 여부 : 통과
시간 : 35분
점수 : +12 오...?


테스트 1 〉	통과 (0.04ms, 33.4MB)
테스트 2 〉	통과 (8.94ms, 38.2MB)
테스트 3 〉	통과 (5.97ms, 38.2MB)
테스트 4 〉	통과 (6.07ms, 38.4MB)
테스트 5 〉	통과 (6.04ms, 38.5MB)
테스트 6 〉	통과 (6.07ms, 38.5MB)
테스트 7 〉	통과 (5.93ms, 38.6MB)
테스트 8 〉	통과 (7.07ms, 38.6MB)
테스트 9 〉	통과 (0.04ms, 33.5MB)
테스트 10 〉	통과 (0.14ms, 33.4MB)
테스트 11 〉	통과 (0.04ms, 33.4MB)
테스트 12 〉	통과 (0.04ms, 33.4MB)
테스트 13 〉	통과 (0.04ms, 33.4MB)

효율성 테스트
테스트 1 〉	통과 (27.84ms, 51.4MB)
테스트 2 〉	통과 (48.42ms, 39.4MB)
테스트 3 〉	통과 (22.57ms, 43.8MB)
테스트 4 〉	통과 (23.08ms, 43.8MB)
테스트 5 〉	통과 (22.25ms, 43.8MB)
테스트 6 〉	통과 (24.35ms, 43.7MB)
테스트 7 〉	통과 (25.03ms, 43.8MB)
테스트 8 〉	통과 (25.30ms, 46.8MB)
*/

/*
    같은 알파벳이 2개 붙어있는 짝 찾기 => 이렇게 반복했을 때 성공적으로 수행되는지
    재귀? 증감 연산자로 안 같을 때까지 계속 볼까?
    틀린 이유 1) substr로 점점 없애버리니까 i가 s.length까지 갈 일이 없어서
   
function solution(s) {
  
  for (let i = 0; i < s.length; ) {
    s[i] === s[i + 1] ? s.substr(i, 2) : i++;
  }
  for (let i = 0; i < s.length; ) {
    // ba 안 같으니까 다음꺼로
    // 다음꺼 왔더니 a,a 같으니까 없애고 다시 0으로 가야겠네
    // 언제까지 반복할지 어떻게 알려주지?
    // 스택 사용?
    if (s[i] === s[i + 1]) {
      s.substr(i, 2);
      i = 0;
    }
    i++;
  }
  return s.length ? 0 : 1;
}
 */

// 스택 사용해서 풀기
function solution(s) {
  const stack = [];
  for (let i = 0; i < s.length; i++) {
    // 마지막 stack이랑 같으면 퉤! 아니면 냠
    s[i] === stack[stack.length - 1] ? stack.pop() : stack.push(s[i]);
  }
  return stack.length ? 0 : 1;
}
