// level.1

// 테스트 1 〉	통과 (0.04ms, 33.5MB)
// 테스트 2 〉	통과 (0.04ms, 33.5MB)
// 테스트 3 〉	통과 (0.04ms, 33.4MB)
// 테스트 4 〉	통과 (0.05ms, 33.5MB)
// 테스트 5 〉	통과 (0.05ms, 33.4MB)
// 테스트 6 〉	통과 (0.05ms, 33.5MB)
// 테스트 7 〉	통과 (0.15ms, 33.4MB)
// 테스트 8 〉	통과 (0.14ms, 33.4MB)
// 테스트 9 〉	통과 (0.14ms, 33.6MB)
// 테스트 10 〉	통과 (0.15ms, 33.5MB)
// 테스트 11 〉	통과 (0.14ms, 33.4MB)
// 테스트 12 〉	통과 (0.14ms, 33.4MB)
// 테스트 13 〉	통과 (0.14ms, 33.5MB)
// 테스트 14 〉	통과 (0.14ms, 33.4MB)
// 테스트 15 〉	통과 (0.15ms, 33.6MB)
// 테스트 16 〉	통과 (0.23ms, 33.4MB)
// 테스트 17 〉	통과 (0.16ms, 33.4MB)
// 테스트 18 〉	통과 (0.21ms, 33.4MB)
// 테스트 19 〉	통과 (0.17ms, 33.6MB)
// 테스트 20 〉	통과 (0.14ms, 33.4MB)
// 테스트 21 〉	통과 (0.13ms, 33.4MB)
// 테스트 22 〉	통과 (0.13ms, 33.5MB)
// 테스트 23 〉	통과 (0.18ms, 33.4MB)


function solution(d, budget) {
    // d : 부서별 신청 금액이 담겨있는 배열
    // budget :  전체 예산
    
    // 예산범위 내에서 최대로 지원할 수 있는 부서의 개수를 리턴
    
    // 만약 d내의 모든 예산을 더했을때 budget보다 작거나 같으면, 모든 부서를 지원가능함.
    // 최대로 지원? -> 작은 예산부터 더해나가자
    
    // 먼저 d를 오름차순으로 정렬
    // 앞에서부터 차근차근 더해나가자
    // 그러면서 count를 1씩 증가
    // 만약 합이 budget을 초과한다? count리턴
    
    
    let dept = d.sort((a,b)=> a - b);
    
    let total = 0;
    let count = 0;
    
    for (let i = 0; i < dept.length; i++){
        
        total += dept[i]
        if (total > budget) return count;
        count++
    }
    
    return count;
}